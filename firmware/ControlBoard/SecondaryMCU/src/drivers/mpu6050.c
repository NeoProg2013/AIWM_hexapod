/* ================================================================================================ *
| FIFO packet structure:
| [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ]
|  00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15      
| [GYRO X][GYRO X][GYRO Y][GYRO Y][GYRO Z][GYRO Z][      ]
|  16  17  18  19  20  21  22  23  24  25  28  27  28  29  
* ================================================================================================ */
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "project_base.h"
#include "i2c1.h"
#include "mpu6050.h"
#include "systimer.h"
#define MPU6050_I2C_ADDRESS                             (0x68 << 1)
#define CHIP_ID                                         (0x34)

#define FIFO_PACKET_SIZE                                (30)        // bytes
#define M_PI                                            (3.14159265f)


static const uint8_t DMP_MEMORY_BINARY[] = {
    // bank 0, 256 bytes
    0xFB,0x00,0x00,0x3E,0x00,0x0B,0x00,0x36,0x00,0x01,0x00,0x02,0x00,0x03,0x00,0x00,
    0x00,0x65,0x00,0x54,0xFF,0xEF,0x00,0x00,0xFA,0x80,0x00,0x0B,0x12,0x82,0x00,0x01,
    0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x28,0x00,0x00,0xFF,0xFF,0x45,0x81,0xFF,0xFF,0xFA,0x72,0x00,0x00,0x00,0x00,
    0x00,0x00,0x03,0xE8,0x00,0x00,0x00,0x01,0x00,0x01,0x7F,0xFF,0xFF,0xFE,0x80,0x01,
    0x00,0x1B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x3E,0x03,0x30,0x40,0x00,0x00,0x00,0x02,0xCA,0xE3,0x09,0x3E,0x80,0x00,0x00,
    0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x60,0x00,0x00,0x00,
    0x41,0xFF,0x00,0x00,0x00,0x00,0x0B,0x2A,0x00,0x00,0x16,0x55,0x00,0x00,0x21,0x82,
    0xFD,0x87,0x26,0x50,0xFD,0x80,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x05,0x80,0x00,
    0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,
    0x40,0x00,0x00,0x00,0x00,0x00,0x04,0x6F,0x00,0x02,0x65,0x32,0x00,0x00,0x5E,0xC0,
    0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0xFB,0x8C,0x6F,0x5D,0xFD,0x5D,0x08,0xD9,0x00,0x7C,0x73,0x3B,0x00,0x6C,0x12,0xCC,
    0x32,0x00,0x13,0x9D,0x32,0x00,0xD0,0xD6,0x32,0x00,0x08,0x00,0x40,0x00,0x01,0xF4,
    0xFF,0xE6,0x80,0x79,0x02,0x00,0x00,0x00,0x00,0x00,0xD0,0xD6,0x00,0x00,0x27,0x10,
    // bank 1, 256 bytes
    0xFB,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,
    0x00,0x00,0xFA,0x36,0xFF,0xBC,0x30,0x8E,0x00,0x05,0xFB,0xF0,0xFF,0xD9,0x5B,0xC8,
    0xFF,0xD0,0x9A,0xBE,0x00,0x00,0x10,0xA9,0xFF,0xF4,0x1E,0xB2,0x00,0xCE,0xBB,0xF7,
    0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x04,0x00,0x02,0x00,0x02,0x02,0x00,0x00,0x0C,
    0xFF,0xC2,0x80,0x00,0x00,0x01,0x80,0x00,0x00,0xCF,0x80,0x00,0x40,0x00,0x00,0x00,
    0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x14,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x03,0x3F,0x68,0xB6,0x79,0x35,0x28,0xBC,0xC6,0x7E,0xD1,0x6C,
    0x80,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0xB2,0x6A,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xF0,0x00,0x00,0x00,0x30,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x25,0x4D,0x00,0x2F,0x70,0x6D,0x00,0x00,0x05,0xAE,0x00,0x0C,0x02,0xD0,
    // bank 2, 256 bytes
    0x00,0x00,0x00,0x00,0x00,0x65,0x00,0x54,0xFF,0xEF,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x01,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x0C,0x00,0x00,0x00,0x01,0x00,
    0x00,0x00,0x00,0x00,0x00,0x65,0x00,0x00,0x00,0x54,0x00,0x00,0xFF,0xEF,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x1B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,
    0x00,0x1B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // bank 3, 256 bytes
    0xD8,0xDC,0xBA,0xA2,0xF1,0xDE,0xB2,0xB8,0xB4,0xA8,0x81,0x91,0xF7,0x4A,0x90,0x7F,
    0x91,0x6A,0xF3,0xF9,0xDB,0xA8,0xF9,0xB0,0xBA,0xA0,0x80,0xF2,0xCE,0x81,0xF3,0xC2,
    0xF1,0xC1,0xF2,0xC3,0xF3,0xCC,0xA2,0xB2,0x80,0xF1,0xC6,0xD8,0x80,0xBA,0xA7,0xDF,
    0xDF,0xDF,0xF2,0xA7,0xC3,0xCB,0xC5,0xB6,0xF0,0x87,0xA2,0x94,0x24,0x48,0x70,0x3C,
    0x95,0x40,0x68,0x34,0x58,0x9B,0x78,0xA2,0xF1,0x83,0x92,0x2D,0x55,0x7D,0xD8,0xB1,
    0xB4,0xB8,0xA1,0xD0,0x91,0x80,0xF2,0x70,0xF3,0x70,0xF2,0x7C,0x80,0xA8,0xF1,0x01,
    0xB0,0x98,0x87,0xD9,0x43,0xD8,0x86,0xC9,0x88,0xBA,0xA1,0xF2,0x0E,0xB8,0x97,0x80,
    0xF1,0xA9,0xDF,0xDF,0xDF,0xAA,0xDF,0xDF,0xDF,0xF2,0xAA,0xC5,0xCD,0xC7,0xA9,0x0C,
    0xC9,0x2C,0x97,0x97,0x97,0x97,0xF1,0xA9,0x89,0x26,0x46,0x66,0xB0,0xB4,0xBA,0x80,
    0xAC,0xDE,0xF2,0xCA,0xF1,0xB2,0x8C,0x02,0xA9,0xB6,0x98,0x00,0x89,0x0E,0x16,0x1E,
    0xB8,0xA9,0xB4,0x99,0x2C,0x54,0x7C,0xB0,0x8A,0xA8,0x96,0x36,0x56,0x76,0xF1,0xB9,
    0xAF,0xB4,0xB0,0x83,0xC0,0xB8,0xA8,0x97,0x11,0xB1,0x8F,0x98,0xB9,0xAF,0xF0,0x24,
    0x08,0x44,0x10,0x64,0x18,0xF1,0xA3,0x29,0x55,0x7D,0xAF,0x83,0xB5,0x93,0xAF,0xF0,
    0x00,0x28,0x50,0xF1,0xA3,0x86,0x9F,0x61,0xA6,0xDA,0xDE,0xDF,0xD9,0xFA,0xA3,0x86,
    0x96,0xDB,0x31,0xA6,0xD9,0xF8,0xDF,0xBA,0xA6,0x8F,0xC2,0xC5,0xC7,0xB2,0x8C,0xC1,
    0xB8,0xA2,0xDF,0xDF,0xDF,0xA3,0xDF,0xDF,0xDF,0xD8,0xD8,0xF1,0xB8,0xA8,0xB2,0x86,
    // bank 4, 256 bytes
    0xB4,0x98,0x0D,0x35,0x5D,0xB8,0xAA,0x98,0xB0,0x87,0x2D,0x35,0x3D,0xB2,0xB6,0xBA,
    0xAF,0x8C,0x96,0x19,0x8F,0x9F,0xA7,0x0E,0x16,0x1E,0xB4,0x9A,0xB8,0xAA,0x87,0x2C,
    0x54,0x7C,0xB9,0xA3,0xDE,0xDF,0xDF,0xA3,0xB1,0x80,0xF2,0xC4,0xCD,0xC9,0xF1,0xB8,
    0xA9,0xB4,0x99,0x83,0x0D,0x35,0x5D,0x89,0xB9,0xA3,0x2D,0x55,0x7D,0xB5,0x93,0xA3,
    0x0E,0x16,0x1E,0xA9,0x2C,0x54,0x7C,0xB8,0xB4,0xB0,0xF1,0x97,0x83,0xA8,0x11,0x84,
    0xA5,0x09,0x98,0xA3,0x83,0xF0,0xDA,0x24,0x08,0x44,0x10,0x64,0x18,0xD8,0xF1,0xA5,
    0x29,0x55,0x7D,0xA5,0x85,0x95,0x02,0x1A,0x2E,0x3A,0x56,0x5A,0x40,0x48,0xF9,0xF3,
    0xA3,0xD9,0xF8,0xF0,0x98,0x83,0x24,0x08,0x44,0x10,0x64,0x18,0x97,0x82,0xA8,0xF1,
    0x11,0xF0,0x98,0xA2,0x24,0x08,0x44,0x10,0x64,0x18,0xDA,0xF3,0xDE,0xD8,0x83,0xA5,
    0x94,0x01,0xD9,0xA3,0x02,0xF1,0xA2,0xC3,0xC5,0xC7,0xD8,0xF1,0x84,0x92,0xA2,0x4D,
    0xDA,0x2A,0xD8,0x48,0x69,0xD9,0x2A,0xD8,0x68,0x55,0xDA,0x32,0xD8,0x50,0x71,0xD9,
    0x32,0xD8,0x70,0x5D,0xDA,0x3A,0xD8,0x58,0x79,0xD9,0x3A,0xD8,0x78,0x93,0xA3,0x4D,
    0xDA,0x2A,0xD8,0x48,0x69,0xD9,0x2A,0xD8,0x68,0x55,0xDA,0x32,0xD8,0x50,0x71,0xD9,
    0x32,0xD8,0x70,0x5D,0xDA,0x3A,0xD8,0x58,0x79,0xD9,0x3A,0xD8,0x78,0xA8,0x8A,0x9A,
    0xF0,0x28,0x50,0x78,0x9E,0xF3,0x88,0x18,0xF1,0x9F,0x1D,0x98,0xA8,0xD9,0x08,0xD8,
    0xC8,0x9F,0x12,0x9E,0xF3,0x15,0xA8,0xDA,0x12,0x10,0xD8,0xF1,0xAF,0xC8,0x97,0x87,
    // bank 5, 256 bytes
    0x34,0xB5,0xB9,0x94,0xA4,0x21,0xF3,0xD9,0x22,0xD8,0xF2,0x2D,0xF3,0xD9,0x2A,0xD8,
    0xF2,0x35,0xF3,0xD9,0x32,0xD8,0x81,0xA4,0x60,0x60,0x61,0xD9,0x61,0xD8,0x6C,0x68,
    0x69,0xD9,0x69,0xD8,0x74,0x70,0x71,0xD9,0x71,0xD8,0xB1,0xA3,0x84,0x19,0x3D,0x5D,
    0xA3,0x83,0x1A,0x3E,0x5E,0x93,0x10,0x30,0x81,0x10,0x11,0xB8,0xB0,0xAF,0x8F,0x94,
    0xF2,0xDA,0x3E,0xD8,0xB4,0x9A,0xA8,0x87,0x29,0xDA,0xF8,0xD8,0x87,0x9A,0x35,0xDA,
    0xF8,0xD8,0x87,0x9A,0x3D,0xDA,0xF8,0xD8,0xB1,0xB9,0xA4,0x98,0x85,0x02,0x2E,0x56,
    0xA5,0x81,0x00,0x0C,0x14,0xA3,0x97,0xB0,0x8A,0xF1,0x2D,0xD9,0x28,0xD8,0x4D,0xD9,
    0x48,0xD8,0x6D,0xD9,0x68,0xD8,0xB1,0x84,0x0D,0xDA,0x0E,0xD8,0xA3,0x29,0x83,0xDA,
    0x2C,0x0E,0xD8,0xA3,0x84,0x49,0x83,0xDA,0x2C,0x4C,0x0E,0xD8,0xB8,0xB0,0xA8,0x8A,
    0x9A,0xF5,0x20,0xAA,0xDA,0xDF,0xD8,0xA8,0x40,0xAA,0xD0,0xDA,0xDE,0xD8,0xA8,0x60,
    0xAA,0xDA,0xD0,0xDF,0xD8,0xF1,0x97,0x86,0xA8,0x31,0x9B,0x06,0x99,0x07,0xAB,0x97,
    0x28,0x88,0x9B,0xF0,0x0C,0x20,0x14,0x40,0xB8,0xB0,0xB4,0xA8,0x8C,0x9C,0xF0,0x04,
    0x28,0x51,0x79,0x1D,0x30,0x14,0x38,0xB2,0x82,0xAB,0xD0,0x98,0x2C,0x50,0x50,0x78,
    0x78,0x9B,0xF1,0x1A,0xB0,0xF0,0x8A,0x9C,0xA8,0x29,0x51,0x79,0x8B,0x29,0x51,0x79,
    0x8A,0x24,0x70,0x59,0x8B,0x20,0x58,0x71,0x8A,0x44,0x69,0x38,0x8B,0x39,0x40,0x68,
    0x8A,0x64,0x48,0x31,0x8B,0x30,0x49,0x60,0xA5,0x88,0x20,0x09,0x71,0x58,0x44,0x68,
    // bank 6, 256 bytes
    0x11,0x39,0x64,0x49,0x30,0x19,0xF1,0xAC,0x00,0x2C,0x54,0x7C,0xF0,0x8C,0xA8,0x04,
    0x28,0x50,0x78,0xF1,0x88,0x97,0x26,0xA8,0x59,0x98,0xAC,0x8C,0x02,0x26,0x46,0x66,
    0xF0,0x89,0x9C,0xA8,0x29,0x51,0x79,0x24,0x70,0x59,0x44,0x69,0x38,0x64,0x48,0x31,
    0xA9,0x88,0x09,0x20,0x59,0x70,0xAB,0x11,0x38,0x40,0x69,0xA8,0x19,0x31,0x48,0x60,
    0x8C,0xA8,0x3C,0x41,0x5C,0x20,0x7C,0x00,0xF1,0x87,0x98,0x19,0x86,0xA8,0x6E,0x76,
    0x7E,0xA9,0x99,0x88,0x2D,0x55,0x7D,0x9E,0xB9,0xA3,0x8A,0x22,0x8A,0x6E,0x8A,0x56,
    0x8A,0x5E,0x9F,0xB1,0x83,0x06,0x26,0x46,0x66,0x0E,0x2E,0x4E,0x6E,0x9D,0xB8,0xAD,
    0x00,0x2C,0x54,0x7C,0xF2,0xB1,0x8C,0xB4,0x99,0xB9,0xA3,0x2D,0x55,0x7D,0x81,0x91,
    0xAC,0x38,0xAD,0x3A,0xB5,0x83,0x91,0xAC,0x2D,0xD9,0x28,0xD8,0x4D,0xD9,0x48,0xD8,
    0x6D,0xD9,0x68,0xD8,0x8C,0x9D,0xAE,0x29,0xD9,0x04,0xAE,0xD8,0x51,0xD9,0x04,0xAE,
    0xD8,0x79,0xD9,0x04,0xD8,0x81,0xF3,0x9D,0xAD,0x00,0x8D,0xAE,0x19,0x81,0xAD,0xD9,
    0x01,0xD8,0xF2,0xAE,0xDA,0x26,0xD8,0x8E,0x91,0x29,0x83,0xA7,0xD9,0xAD,0xAD,0xAD,
    0xAD,0xF3,0x2A,0xD8,0xD8,0xF1,0xB0,0xAC,0x89,0x91,0x3E,0x5E,0x76,0xF3,0xAC,0x2E,
    0x2E,0xF1,0xB1,0x8C,0x5A,0x9C,0xAC,0x2C,0x28,0x28,0x28,0x9C,0xAC,0x30,0x18,0xA8,
    0x98,0x81,0x28,0x34,0x3C,0x97,0x24,0xA7,0x28,0x34,0x3C,0x9C,0x24,0xF2,0xB0,0x89,
    0xAC,0x91,0x2C,0x4C,0x6C,0x8A,0x9B,0x2D,0xD9,0xD8,0xD8,0x51,0xD9,0xD8,0xD8,0x79,
    // bank 7, 138 bytes (remainder)
    0xD9,0xD8,0xD8,0xF1,0x9E,0x88,0xA3,0x31,0xDA,0xD8,0xD8,0x91,0x2D,0xD9,0x28,0xD8,
    0x4D,0xD9,0x48,0xD8,0x6D,0xD9,0x68,0xD8,0xB1,0x83,0x93,0x35,0x3D,0x80,0x25,0xDA,
    0xD8,0xD8,0x85,0x69,0xDA,0xD8,0xD8,0xB4,0x93,0x81,0xA3,0x28,0x34,0x3C,0xF3,0xAB,
    0x8B,0xF8,0xA3,0x91,0xB6,0x09,0xB4,0xD9,0xAB,0xDE,0xFA,0xB0,0x87,0x9C,0xB9,0xA3,
    0xDD,0xF1,0xA3,0xA3,0xA3,0xA3,0x95,0xF1,0xA3,0xA3,0xA3,0x9D,0xF1,0xA3,0xA3,0xA3,
    0xA3,0xF2,0xA3,0xB4,0x90,0x80,0xF2,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,
    0xA3,0xB2,0xA3,0xA3,0xA3,0xA3,0xA3,0xA3,0xB0,0x87,0xB5,0x99,0xF1,0xA3,0xA3,0xA3,
    0x98,0xF1,0xA3,0xA3,0xA3,0xA3,0x97,0xA3,0xA3,0xA3,0xA3,0xF3,0x9B,0xA3,0xA3,0xDC,
    0xB9,0xA7,0xF1,0x26,0x26,0x26,0xD8,0xD8,0xFF
};

static const uint8_t DMP_CONFIG_BINARY[] = {
    // BANK OFFSET LENGTH [DATA]
    0x03,0x7B,0x03,0x4C,0xCD,0x6C,                    // FCFG_1  inv_set_gyro_calibration
    0x03,0xAB,0x03,0x36,0x56,0x76,                    // FCFG_3  inv_set_gyro_calibration
    0x00,0x68,0x04,0x02,0xCB,0x47,0xA2,               // D_0_104 inv_set_gyro_calibration
    0x02,0x18,0x04,0x00,0x05,0x8B,0xC1,               // D_0_24  inv_set_gyro_calibration
    0x01,0x0C,0x04,0x00,0x00,0x00,0x00,               // D_1_152 inv_set_accel_calibration
    0x03,0x7F,0x06,0x0C,0xC9,0x2C,0x97,0x97,0x97,     // FCFG_2  inv_set_accel_calibration
    0x03,0x89,0x03,0x26,0x46,0x66,                    // FCFG_7  inv_set_accel_calibration
    0x00,0x6C,0x02,0x20,0x00,                         // D_0_108 inv_set_accel_calibration
    0x01,0xEC,0x04,0x00,0x00,0x40,0x00,               // D_1_236 inv_apply_endian_accel
    0x03,0x7F,0x06,0x0C,0xC9,0x2C,0x97,0x97,0x97,     // FCFG_2  inv_set_mpu_sensors
    0x04,0x09,0x04,0x87,0x2D,0x35,0x3D,               // FCFG_5  inv_set_bias_update
    0x00,0xA3,0x01,0x00,                              // D_0_163 inv_set_dead_zone
    0x07,0x86,0x01,0xFE,                              // CFG_6   inv_set_fifo_interupt
    0x07,0x41,0x05,0xF1,0x20,0x28,0x30,0x38,          // CFG_8   inv_send_quaternion
    0x07,0x7E,0x01,0x30,                              // CFG_16  inv_set_footer

    0x07,0x46,0x01,0x9A,                              // CFG_GYRO_SOURCE inv_send_gyro
    0x07,0x47,0x04,0xF1,0x28,0x30,0x38,               // CFG_9 inv_send_gyro -> inv_construct3_fifo

    0x02,0x16,0x02,0x00,0x00                          // D_0_22  inv_set_fifo_rate 
};

#define REG_SMPLRT_DIV                      (0x19)
#define REG_CONFIG                          (0x1A)
#define REG_GYRO_CONFIG                     (0x1B)
#define REG_ACCEL_CONFIG                    (0x1C)
#define REG_INT_CONFIG                      (0x37)
#define REG_INT_ENABLE                      (0x38)
#define REG_USER_CTRL                       (0x6A)
#define REG_PWR_MGMT_1                      (0x6B)
#define REG_BANK_SEL                        (0x6D)   
#define REG_MEM_START_ADDR                  (0x6E)
#define REG_MEM_R_W                         (0x6F)
#define REG_DMP_CFG_1                       (0x70)
#define REG_DMP_CFG_2                       (0x71)
#define REG_FIFO_COUNTH                     (0x72)
#define REG_FIFO_R_W                        (0x74)
#define REG_WHO_AM_I                        (0x75)

#define CFG_DLPF_CFG_MASK                   (0x07)
#define DLPF_BW_256                         (0x00)
#define DLPF_BW_188                         (0x01)
#define DLPF_BW_98                          (0x02)
#define DLPF_BW_42                          (0x03)
#define DLPF_BW_20                          (0x04)
#define DLPF_BW_10                          (0x05)
#define DLPF_BW_5                           (0x06)

#define PWR1_CLKSEL_MASK                    (0x07)
#define CLOCK_INTERNAL                      (0x00)
#define CLOCK_PLL_XGYRO                     (0x01)
#define CLOCK_PLL_YGYRO                     (0x02)
#define CLOCK_PLL_ZGYRO                     (0x03)
#define CLOCK_PLL_EXT32K                    (0x04)
#define CLOCK_PLL_EXT19M                    (0x05)

#define ACONFIG_AFS_SEL_MASK                (0x18)
#define ACCEL_AFS_2                         (0x00)
#define ACCEL_AFS_4                         (0x08)
#define ACCEL_AFS_8                         (0x10)
#define ACCEL_AFS_16                        (0x18)

#define GCONFIG_FS_SEL_MASK                 (0x18)
#define GYRO_FS_250                         (0x00)
#define GYRO_FS_500                         (0x08)
#define GYRO_FS_1000                        (0x10)
#define GYRO_FS_2000                        (0x18)

#define USERCTRL_DMP_EN_MASK                (0x80)
#define USERCTRL_DMP_EN                     (0x80)
#define USERCTRL_DMP_DIS                    (0x00)

#define USERCTRL_FIFO_EN_MASK               (0x40)
#define USERCTRL_FIFO_EN                    (0x40)
#define USERCTRL_FIFO_DIS                   (0x00)

#define USERCTRL_FIFO_RESET_MASK            (0x04)
#define USERCTRL_FIFO_RESET                 (0x04)

#define PWR1_DEVICE_RESET_MASK              (0x80)
#define PWR1_DEVICE_RESET                   (0x80)

#define PWR1_SLEEP_MASK                     (0x40)
#define PWR1_SLEEP_EN                       (0x40)
#define PWR1_SLEEP_DIS                      (0x00)


static bool write_memory_block(const uint8_t* data, uint32_t address, uint32_t bank, uint32_t data_size);
static bool write_dmp_config();



//  ***************************************************************************
/// @brief  MPU6050 initialization
/// @return true - success, false - i2c error
//  ***************************************************************************
bool mpu6050_init(void) {
    uint8_t reg = 0; // Check device ID
    if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_WHO_AM_I, 1, &reg, 1)) return false;
    if ((reg >> 1) != CHIP_ID) {
        return false;
    }

    // Software reset
    if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_PWR_MGMT_1, 1, &reg, 1)) return false;
    reg &= ~PWR1_DEVICE_RESET_MASK;
    reg |= PWR1_DEVICE_RESET;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_PWR_MGMT_1, 1, &reg, 1)) return false;
    delay_ms(30);

    // Disable sleep mode
    if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_PWR_MGMT_1, 1, &reg, 1)) return false;
    reg &= ~PWR1_SLEEP_MASK;
    reg |= PWR1_SLEEP_DIS;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_PWR_MGMT_1, 1, &reg, 1)) return false;

    // Load DMP firmware (reverse engineering)
    if (!write_memory_block(DMP_MEMORY_BINARY, 0, 0, sizeof(DMP_MEMORY_BINARY))) return false;

    // Load DMP configuration (reverse engineering)
    if (!write_dmp_config()) return false;

    // Set clock source
    if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_PWR_MGMT_1, 1, &reg, 1)) return false;
    reg &= ~PWR1_CLKSEL_MASK;
    reg |= CLOCK_PLL_XGYRO;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_PWR_MGMT_1, 1, &reg, 1)) return false;

    // Setup internal low pass filter
    if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_CONFIG, 1, &reg, 1)) return false;
    reg &= ~CFG_DLPF_CFG_MASK;
    reg |= DLPF_BW_42;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_CONFIG, 1, &reg, 1)) return false;

    // Set sample rate divisor (1khz / (1 + 4) = 200Hz)
    reg = 0x04;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_SMPLRT_DIV, 1, &reg, 1)) return false;

    // Set accel range +/- 2g
    if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_ACCEL_CONFIG, 1, &reg, 1)) return false;
    reg &= ~ACONFIG_AFS_SEL_MASK;
    reg |= ACCEL_AFS_2;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_ACCEL_CONFIG, 1, &reg, 1)) return false;

    // Set gyro range +/- 2000
    if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_GYRO_CONFIG, 1, &reg, 1)) return false;
    reg &= ~GCONFIG_FS_SEL_MASK;
    reg |= GYRO_FS_2000;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_GYRO_CONFIG, 1, &reg, 1)) return false;

    // Set DMP configuration registers (reverse engineering)
    reg = 0x03;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_DMP_CFG_1, 1, &reg, 1)) return false;
    reg = 0x00;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_DMP_CFG_2, 1, &reg, 1)) return false;

    // Disable FIFO and DMP
    reg = 0x00;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_USER_CTRL, 1, &reg, 1)) return false;

    // Disable all IRQ
    reg = 0x00;
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_INT_ENABLE, 1, &reg, 1)) return false;
    
    return true;
}

//  ***************************************************************************
/// @brief  MPU6050 start DMP
/// @return true - success, false - i2c error
//  ***************************************************************************
bool mpu6050_start(void) {
    uint8_t reg = 0x0C; // Reset FIFO and DMP
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_USER_CTRL, 1, &reg, 1)) return false;

    reg = 0xC0; // Enable FIFO and DMP
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_USER_CTRL, 1, &reg, 1)) return false;
    
    return true;
}

//  ***************************************************************************
/// @brief  MPU6050 stop DMP
/// @return true - success, false - i2c error
//  ***************************************************************************
bool mpu6050_stop(void) {
    uint8_t reg = 0x00; // Disable FIFO and DMP
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_USER_CTRL, 1, &reg, 1)) return false;

    reg = 0x0C; // Reset FIFO and DMP
    if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_USER_CTRL, 1, &reg, 1)) return false;

    return true;
}

//  ***************************************************************************
/// @brief  Check data ready
/// @param  is_ready: true - data is ready, false - no
/// @return true - check success, false - i2c error
//  ***************************************************************************
bool mpu6050_is_data_ready(bool* is_ready) {
    *is_ready = false;
    
    uint8_t buffer[2] = { 0 }; // Get FIFO buffer size
    if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_FIFO_COUNTH, 1, buffer, 2)) return false;
    uint32_t fifo_bytes_count = ((uint16_t)buffer[0] << 8) | buffer[1];
    
    // Check FIFO buffer size
    if (fifo_bytes_count == 0) {
        return true;
    }
    if ((fifo_bytes_count % FIFO_PACKET_SIZE) != 0) { // Overrun
        uint8_t reg = 0;
        if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_USER_CTRL, 1, &reg, 1)) return false;
        reg &= ~USERCTRL_FIFO_RESET_MASK;
        reg |= USERCTRL_FIFO_RESET;
        i2c1_write(MPU6050_I2C_ADDRESS, REG_USER_CTRL, 1, &reg, 1);
        return true;
    }
    *is_ready = true;
    return true;
}

//  ***************************************************************************
/// @brief  Read data
/// @param  xy_angles: buffer for XY angles
/// @return true - read success, false - i2c error
//  ***************************************************************************
bool mpu6050_read_data(float* xy_angles) {
    uint8_t data[32] = {0};
    while (true) { // Read last data from FIFO buffer
        bool is_ready = false;
        if (!mpu6050_is_data_ready(&is_ready)) return false;
        
        if (!is_ready) {
            break;
        }
        
        if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_FIFO_R_W, 1, data, FIFO_PACKET_SIZE)) return false;
    }
    
    // Parse quaternions
    int16_t raw_q[4] = { 0 };
    raw_q[0] = ((int16_t)data[0]  << 8) | data[1];
    raw_q[1] = ((int16_t)data[4]  << 8) | data[5];
    raw_q[2] = ((int16_t)data[8]  << 8) | data[9];
    raw_q[3] = ((int16_t)data[12] << 8) | data[13];

    // Scaling
    float Q[4] = { 0 };    // WXYZ
    Q[0] = raw_q[0] / 16384.0f;
    Q[1] = raw_q[1] / 16384.0f;
    Q[2] = raw_q[2] / 16384.0f;
    Q[3] = raw_q[3] / 16384.0f;

    // Euler angles
    xy_angles[0] = atan2(2.0f * (Q[0] * Q[1] + Q[2] * Q[3]), 1.0f - 2.0f * (Q[1] * Q[1] + Q[2] * Q[2]));
    xy_angles[1] = asin(2.0f * (Q[0] * Q[2] - Q[3] * Q[1]));
    xy_angles[0] *= 180.0f / M_PI;
    xy_angles[1] *= 180.0f / M_PI;
    
    return true;
}






#define MAX_BLOCK_SIZE            (64)
//  ***************************************************************************
/// @brief  Write memory block to MPU6050
/// @param  data: data for write
/// @param  address: destination address
/// @param  bank: bank number
/// @param  data_size: bytes count for write
/// @return true - success, false - i2c error
//  ***************************************************************************
static bool write_memory_block(const uint8_t* data, uint32_t address, uint32_t bank, uint32_t data_size)  {
    
    for (uint32_t i = 0; i < data_size; i += MAX_BLOCK_SIZE) {

        // Calculate block size for write
        uint32_t block_size = MAX_BLOCK_SIZE;
        if (i + block_size > data_size) {
            block_size = data_size - i;
        }
        if (block_size > 256 - address) {
            block_size = 256 - address;
        }

        // Read block from FLASH
        uint8_t prog_buffer[MAX_BLOCK_SIZE] = { 0 };
        for (uint32_t j = 0; j < block_size; ++j) {
            prog_buffer[j] = *(data + i + j);
        }

        //
        // Write data
        //

        // Set data bank 
        uint8_t reg = bank & 0x1F;
        if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_BANK_SEL, 1, &reg, 1)) return false;

        // Set start address
        reg = address;
        if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_MEM_START_ADDR, 1, &reg, 1)) return false;
 
        // Write block to MPU6050
        if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_MEM_R_W, 1, prog_buffer, block_size)) return false;
    
        //
        // Verify data
        //

        // Set data bank 
        reg = bank & 0x1F;
        if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_BANK_SEL, 1, &reg, 1)) return false;

        // Set start address
        reg = address;
        if (!i2c1_write(MPU6050_I2C_ADDRESS, REG_MEM_START_ADDR, 1, &reg, 1)) return false;
        
        // Check written block
        uint8_t verify_buffer[MAX_BLOCK_SIZE] = { 0 };
        if (!i2c1_read(MPU6050_I2C_ADDRESS, REG_MEM_R_W, 1, verify_buffer, block_size)) return false;
        if (memcmp(prog_buffer, verify_buffer, block_size) != 0) {
            return false;
        }

        // Address offset
        address += MAX_BLOCK_SIZE;
        if (address == 256) {
            bank++;
            address = 0;
        }
    }
    return true;
}

//  ***************************************************************************
/// @brief  Write DMP configuration
/// @return true - success, false - i2c error
//  ***************************************************************************
static bool write_dmp_config(void) {
    // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
    const uint8_t* data = DMP_CONFIG_BINARY;
    for (uint32_t i = 0; i < sizeof(DMP_CONFIG_BINARY); /* NONE */) {
        uint8_t bank   = *(data + i++);
        uint8_t offset = *(data + i++);
        uint8_t length = *(data + i++);
        if (!write_memory_block(data + i, offset, bank, length)) return false;
        i += length;
    }
    return true;
}
